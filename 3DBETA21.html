<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Stick Figure Parkour — Platforms + Obstacles</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    .ui {
      position: absolute; left: 12px; top: 12px;
      color: #fff; background: rgba(0,0,0,0.45);
      padding: 8px 10px; border-radius: 6px;
      font-size: 13px; z-index: 10;
    }
  </style>
</head>
<body>
<div class="ui">
  Controls: Arrow Up/Down = forward/back • Arrow Left/Right = strafe • W/S = rotate • Space = jump
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script>
// ===== SCENE =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 1);
dir.position.set(10, 20, 10);
dir.castShadow = true;
dir.shadow.mapSize.width = 2048;
dir.shadow.mapSize.height = 2048;
scene.add(dir);

// Ground
const groundGeo = new THREE.PlaneGeometry(200, 200);
const groundMat = new THREE.MeshPhongMaterial({ color: 0x228B22 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// ===== STICK FIGURE =====
const stickFigure = new THREE.Group();
function makePart(mesh){ mesh.castShadow = true; return mesh; }
const headHeight = 2.8;

const head = makePart(new THREE.Mesh(new THREE.SphereGeometry(0.45, 12, 12),
  new THREE.MeshPhongMaterial({ color: 0xffd1a4 })));
head.position.y = 2.4; stickFigure.add(head);

const body = makePart(new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,1.4,8),
  new THREE.MeshPhongMaterial({ color: 0x000000 })));
body.position.y = 1.45; stickFigure.add(body);

const legGeo = new THREE.CylinderGeometry(0.08,0.08,1,8);
const legMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
const leftLeg = makePart(new THREE.Mesh(legGeo, legMat));
leftLeg.position.set(-0.18, 0.5, 0); stickFigure.add(leftLeg);
const rightLeg = leftLeg.clone(); rightLeg.position.set(0.18, 0.5, 0); stickFigure.add(rightLeg);

const armGeo = new THREE.CylinderGeometry(0.07,0.07,1,8);
const leftArm = makePart(new THREE.Mesh(armGeo, legMat));
leftArm.position.set(-0.45, 1.75, 0); leftArm.rotation.z = Math.PI/4; stickFigure.add(leftArm);
const rightArm = leftArm.clone(); rightArm.position.set(0.45, 1.75, 0); rightArm.rotation.z = -Math.PI/4; stickFigure.add(rightArm);

stickFigure.position.set(0,0,0);
scene.add(stickFigure);

// ===== PLATFORMS =====
const boxes = [];
const walls = []; // tall walls
const boxMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
const wallMat = new THREE.MeshPhongMaterial({ color: 0x654321 });

let currentX = 0, currentY = 0.5, currentZ = -5;
for (let i = 0; i < 25; i++) {
  const width = 2 + Math.random()*1.5;
  const depth = 2 + Math.random()*1.5;
  const height = 0.5 + Math.random()*1.5;
  const box = new THREE.Mesh(new THREE.BoxGeometry(width,height,depth), boxMat);
  box.castShadow = true; box.receiveShadow = true;

  currentX += (Math.random()-0.5)*3;
  currentZ -= 4 + Math.random()*2;
  currentY += 1 + Math.random()*1.5;

  box.position.set(currentX,currentY,currentZ);
  scene.add(box);
  boxes.push(box);

  // every 7th block has a wall in front
  if (i % 7 === 0 && i !== 0) {
    const wall = new THREE.Mesh(new THREE.BoxGeometry(3,4,0.5), wallMat);
    wall.castShadow = true; wall.receiveShadow = true;
    wall.position.set(box.position.x, box.position.y+2, box.position.z-3);
    scene.add(wall);
    walls.push(wall);
  }
}

// ===== MOVING OBSTACLES =====
const obstacles = [];
const obstacleMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
for (let i = 0; i < boxes.length; i += 6) {
  const obstacle = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), obstacleMat);
  obstacle.castShadow = true;
  obstacle.position.set(boxes[i].position.x, boxes[i].position.y+1, boxes[i].position.z+2);
  scene.add(obstacle);
  obstacles.push({ mesh: obstacle, baseX: obstacle.position.x, baseZ: obstacle.position.z,
    dir: Math.random()>0.5?1:-1, axis: Math.random()>0.5?"x":"z", speed:0.03+Math.random()*0.02 });
}

// ===== CAMERA =====
camera.position.set(0,5,12);
camera.lookAt(stickFigure.position);

// ===== CONTROLS & PHYSICS =====
const keys = {};
const speed = 0.22, strafeSpeed = 0.18, rotationSpeed = 0.12;
let velocityY = 0, gravity = -0.025, jumpStrength = 0.6, isOnGround = true;

window.addEventListener('keydown', e=>{
  keys[e.code]=true;
  if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
  if(e.code==="Space" && isOnGround){ velocityY=jumpStrength; isOnGround=false; }
});
window.addEventListener('keyup', e=>{ keys[e.code]=false; });

// ===== COLLISIONS =====
function checkPlatformCollision(x,z,y){
  for(const box of boxes){
    const halfW=box.geometry.parameters.width/2;
    const halfD=box.geometry.parameters.depth/2;
    const minX=box.position.x-halfW, maxX=box.position.x+halfW;
    const minZ=box.position.z-halfD, maxZ=box.position.z+halfD;
    const topY=box.position.y+box.geometry.parameters.height/2;

    const withinXZ=x>minX && x<maxX && z>minZ && z<maxZ;
    const playerBottom=y, playerTop=y+headHeight;

    // Only land if feet are above and intersect top surface
    if(withinXZ && velocityY<=0 && playerBottom>=topY-0.2 && playerBottom+velocityY<=topY){
      return topY;
    }
  }
  return null;
}
function checkObstacleCollision(){
  for(const obs of obstacles){
    const o=obs.mesh;
    const minX=o.position.x-0.5, maxX=o.position.x+0.5;
    const minY=o.position.y-0.5, maxY=o.position.y+0.5;
    const minZ=o.position.z-0.5, maxZ=o.position.z+0.5;
    const playerBottom=stickFigure.position.y, playerTop=stickFigure.position.y+headHeight;

    const overlapX=stickFigure.position.x>minX && stickFigure.position.x<maxX;
    const overlapZ=stickFigure.position.z>minZ && stickFigure.position.z<maxZ;
    const overlapY=playerTop>minY && playerBottom<maxY;

    if(overlapX&&overlapZ&&overlapY){
      stickFigure.position.set(0,0,0); velocityY=0;
    }
  }
}
function checkWallCollision(candidate){
  for(const wall of walls){
    const halfW=wall.geometry.parameters.width/2;
    const halfD=wall.geometry.parameters.depth/2;
    const minX=wall.position.x-halfW, maxX=wall.position.x+halfW;
    const minY=wall.position.y-wall.geometry.parameters.height/2;
    const maxY=wall.position.y+wall.geometry.parameters.height/2;
    const minZ=wall.position.z-halfD, maxZ=wall.position.z+halfD;
    const playerBottom=stickFigure.position.y, playerTop=stickFigure.position.y+headHeight;

    if(candidate.x>minX&&candidate.x<maxX&&candidate.z>minZ&&candidate.z<maxZ
      && playerTop>minY && playerBottom<maxY){ return true; }
  }
  return false;
}

// ===== ANIMATE =====
function animate(){
  requestAnimationFrame(animate);

  if(keys['KeyW']) stickFigure.rotation.y+=rotationSpeed;
  if(keys['KeyS']) stickFigure.rotation.y-=rotationSpeed;

  const yaw=stickFigure.rotation.y;
  const forward=new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw));
  const right=new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw));

  let forwardInput=(keys['ArrowUp']?1:0)+(keys['ArrowDown']?-1:0);
  let strafeInput=(keys['ArrowRight']?1:0)+(keys['ArrowLeft']?-1:0);

  const candidate=stickFigure.position.clone();
  candidate.add(forward.clone().multiplyScalar(forwardInput*speed));
  candidate.add(right.clone().multiplyScalar(strafeInput*strafeSpeed));

  // prevent wall penetration
  if(!checkWallCollision(candidate)){
    stickFigure.position.x=candidate.x;
    stickFigure.position.z=candidate.z;
  }

  // gravity
  velocityY+=gravity;
  stickFigure.position.y+=velocityY;
  isOnGround=false;

  if(stickFigure.position.y<=0){
    stickFigure.position.y=0; velocityY=0; isOnGround=true;
  }

  const topY=checkPlatformCollision(stickFigure.position.x,stickFigure.position.z,stickFigure.position.y);
  if(topY!==null){ stickFigure.position.y=topY; velocityY=0; isOnGround=true; }

  for(const obs of obstacles){
    if(obs.axis==="x"){ obs.mesh.position.x+=obs.speed*obs.dir;
      if(Math.abs(obs.mesh.position.x-obs.baseX)>2) obs.dir*=-1; }
    else{ obs.mesh.position.z+=obs.speed*obs.dir;
      if(Math.abs(obs.mesh.position.z-obs.baseZ)>2) obs.dir*=-1; }
  }

  checkObstacleCollision();

  const camOffset=new THREE.Vector3(0,5,12).applyAxisAngle(new THREE.Vector3(0,1,0),-stickFigure.rotation.y);
  camera.position.copy(stickFigure.position).add(camOffset);
  camera.lookAt(stickFigure.position.clone().add(new THREE.Vector3(0,1.6,0)));

  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
